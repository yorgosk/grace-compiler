Package compiler;


Helpers

    all = [0 .. 0xFFFF] ;
  	digit = ['0' .. '9'] ;
  	nonzero_digit = ['1' .. '9'] ;
  	letter = ['a' .. 'z'] | ['A' .. 'Z'] ;
  	nondigit = '_' | letter ;
  	/*ex digit_sequence*/
  	sign = '+' | '-' ;
  	hexadecimal_digit = digit | ['a' .. 'f'] | ['A' .. 'F'] ;
  	escape_sequence = '\' ('n' | 't' | 'r' | '0' | '\' | ''' | '"' | ('x' hexadecimal_digit+ hexadecimal_digit+)) ;
  	cr = 13 ;
    lf = 10 ;
    tab = 9 ;
    /*ex s_char*/
    s_char = ([all - [''' + ['"' + ['\' + [lf + cr]]]]] | escape_sequence) ;
  	/*ex s_string*/
  	not_dollar = [all - '$'] ;
  	not_double_dollar = [not_dollar - '$'] ;
  	line_comment = '$' all* ;
    multiline_comment = '$$' not_dollar* '$'+ (not_double_dollar not_dollar* '$'+)* '$' ;


Tokens

  	int_const = digit+;
  	char_const = ''' s_char ''' ;
  	s_char_sequence = (''' s_char ''')+ ;
  	string_literal = '"' ((''' s_char ''')+) '"' ;

    /* keywords */
    and = 'and' ;
    char = 'char' ;
    div = 'div' ;
    do = 'do' ;
    else = 'else' ;
    fun = 'fun' ;
    if = 'if' ;
    int = 'int' ;
    mod = 'mod' ;
    not = 'not' ;
    nothing = 'nothing' ;
    or = 'or' ;
    ref = 'ref' ;
    return = 'return' ;
    then = 'then' ;
    var = 'var' ;
    while = 'while' ;

    /* names */
    id = letter (digit | nondigit)* ;

    /* symbolic operators */
    plus = '+' ;
  	minus = '-' ;
  	division = '/' ;
  	mult = '*' ;
  	hashtag = '#' ;
  	equal = '=' ;
  	unequal = '<>' ;
  	lesser = '<' ;
  	greater = '>' ;
  	lesseq = '<=' ;
  	greateq = '>=' ;

    /* separators */
    comma = ',' ;
  	colon = ':' ;
  	semicolon = ';' ;
  	assignment = '<-' ;
  	l_par = '(' ;
  	r_par = ')' ;
  	l_bracket = '[' ;
  	r_bracket = ']' ;
  	l_brace = '{' ;
  	r_brace = '}' ;

  	identifier = nondigit (digit | nondigit)* ;
  	blank = (cr | lf | tab | ' ')+ ;
    comment = line_comment | multiline_comment ;


Ignored Tokens

    blank,
  	comment;


Productions

    program = func_def ;

    func_def = header local_def* block ;

    header_next_arg = semicolon fpar_def ;
    header = fun id l_par fpar_def header_next_arg* r_par colon ret_type ;

    fpar_def_next_var = comma id ;
    fpar_def = ref id fpar_def_next_var* colon fpar_type ;

    data_type =
        {int} int |
        {char} char ;

    dimension = l_bracket int_const r_bracket ;
    type = data_type dimension* ;

    ret_type =
        {data_type} data_type |
        {nothing} nothing ;

    next_dimension = l_bracket int_const r_bracket ;
    fpar_type = data_type l_bracket r_bracket next_dimension* ;

    local_def =
        {func_def} func_def |
        {func_decl} func_decl |
        {var_def} var_def ;

    var_def_next_var = comma id ;
    var_def = var id var_def_next_var* colon type semicolon ;

    func_decl = header semicolon ;

    stmt =
        {stmt1} semicolon |
        {stmt2} l_value assignment expr semicolon |
        {stmt3} block |
        {stmt4} func_call semicolon |
        {stmt5} if cond then [then_stmt]:stmt else [else_stmt]:stmt |
        {stmt6} while cond do stmt |
        {stmt7} return expr semicolon ;

    /*
    unmatched =
        {if_c_s} if cond stmt |
        {if_c_m_e_u} if cond matched else unmatched ;
    else_m = else matched;
    matched =
        {if_c_m_e_m} if cond matched else_m |
        {s1} s1 |
        {s2} s2 ;
    */

    block = l_brace stmt* r_brace ;

    func_call_next_arg = comma expr;
    func_call = id l_par expr func_call_next_arg* r_par ;

    l_value =
        {l_value1} id |
        {l_value2} string_literal |
        {l_value3} l_value l_bracket expr r_bracket ;

    ops1 =
        {plus1} plus |
        {minus1} minus;
    ops2 =
        {plus2} plus |
        {minus2} minus |
        {mult2} mult |
        {div2} div |
        {mod2} mod;
    next_expr = ops2 expr ;
    expr =
        {int_const} int_const |
        {char_const} char_const |
        {l_value} l_value |
        {func_call} func_call |
        {expr_in_pars} l_par expr r_par |
        {ops1_expr} ops1 expr |
        {expr_next_expr} expr next_expr ;

    boolop =
        {and1} and |
        {or1} or;
    numop =
        {equal2} equal |
        {hashtag2} hashtag |
        {unequal2} unequal |
        {lesser2} lesser |
        {greater2} greater |
        {lesseq2} lesseq |
        {greateq2} greateq;
    /*next_cond = cond1 [next_cond_cond]:cond;*/
    /*next_exp = cond2 expr;*/
    cond =
        {condition1} l_par cond r_par |
        {condition2} not [not_cond]:cond |
        {condition3} [init_cond]:cond boolop [next_cond]:cond |
        {condition4} [init_expr]:expr numop [next_expr]:expr ;
